ЦЕЛЬ ПРОЕКТА: улучшить навыки обращения с асмом. Прокачать навыки написания обьемных проектов. 

Идея: близкая интеграция в си/си++(схожий асм синтаксис)

ГЛОБ. ЦЕЛИ:
- необходимо начать с разработки синтаксиса и идей для возможности языка
- изучить детерминированные конечные автоматы
- потом уже анализ, преобр-е текста в список лексем
- список лексем -> аст дерево через рекурс спуск
- аст дерево -> бинарник
- аст дерево -> асм файл
- реасм с бинарника

СИНТАКСИС:

- добавить оператор взятия рандомного базиса
- добавить что-нибудь с подпространствами
- оператор решения системы линейных ур-й
- оператор взятия размерности простр-ва
- что-нибудь про изоморфизмы
- оператор взятия определителя
- оператор взятия обратной матрицы
- оператор суммы и пересечения простр-в
- что-то про сопряж простр-во
- оператор взятия ядра и образа линейного отображения
- полилинейные отображения?
- теория групп?
- композиция линейных операторов
- оператор взятия хар многочлена
- оператор деления многочленов
- многочлены
- приведение к жнф
- оператор следа матрицы
- взятие алгебр кратности
- взятие геом кратности
- взятие мин многочлена
- рекуренты?
- что-то про формы?

# veclan


## Опишу грамматику языка через регулярные выражения:

#### синтаксис описания:
[abcd] - lexem <br />
SMTH   - rule <br />
{a}*   - repeat a (0 or more times) <br />
a | b  - execute a or b <br />
{a}+   - repeat a (1 or more times) <br />

####  собственно, описание
```
PROG	   := FUNC_DEF | ASSIGN [end_of_file]

FUNC_DEF   := [func_prefix] [ident] [bracket_r_l] {[ident] [arg_separator]}* [bracket_r_r] BODY
BODY       := [bracket_s_l] {IDENT | KEYWORD}* [bracket_s_r]

KEYWORD  := {[ret] RVALUE [end_of_operation]} | 
            {[while] [bracket_r_l] LOGIC [bracket_r_r] BODY} |
            {[if]    [bracket_r_l] LOGIC [bracket_r_r] BODY} | 
            {[if]    [bracket_r_l] LOGIC [bracket_r_r] BODY [else] BODY} |
            {[if]    [bracket_r_l] LOGIC [bracket_r_r] BODY}

IDENT	        := FUNCTION_CALL | ASSIGN [end_of_operation]
FUNCTION_CALL   := [ident] [bracket_r_l] {[ident]}* [bracket_r_r]
ASSIGN          := LVALUE [assign] RVALUE
LVALUE          := [ident]
RVALUE          := ARIFM1 {[add] | [sub] ARIFM1}*

ARIFM1        := ARIFM2 {[mul] | [div] ARIFM2}*
ARIFM2        := ARIFM3 {[pow] ARIFM3}*
ARIFM3        := ARIFM4 | [bracket_r_l] RVALUE [bracket_r_r]
ARIFM4        := LVALUE | [constant]

LOGIC      := LOGIC2 {[equal] | [above] | [s_above] | [under] | [s_under] LOGIC2}*
LOGIC2     := LOGIC3 {[or] LOGIC3}*
LOGIC3     := RVALUE {[and] G_RVALUE}*
```
